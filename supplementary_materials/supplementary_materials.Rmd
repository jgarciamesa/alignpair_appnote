---
title: "COATi: statistical pairwise alignment of protein coding sequences"
subtitle: Supplementary Materials
author: Juan J. Garcia Mesa, Ziqi Zhu, Reed A. Cartwright
mainfont: TeX Gyre Pagella
bibliography: ../alignpair_letter.bib
output:
    "bookdown::pdf_document2":
        numbered_sections: yes
        fig_caption: yes
        keep_tex: true
        latex_engine: lualatex
header-includes:
  - \let\oldthefigure\thefigure
  - \renewcommand{\thefigure}{S\oldthefigure}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo = FALSE}
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(tidyverse))

summary_table = function(results_file, coati_model) {
    # read results_summary data
    results = read.csv(results_file)
    
    # extract dseq values for each aligner
    coati = results |> filter(aligner == coati_model) |> select(dseq)
    clustal = results |> filter(aligner == "clustalo") |> select(dseq)
    macse = results |> filter(aligner == "macse") |> select(dseq)
    mafft = results |> filter(aligner == "mafft") |> select(dseq)
    prank = results |> filter(aligner == "prank") |> select(dseq)
    
    stats_table = data.frame(dseq = c(mean(coati$dseq, na.rm = TRUE),
                          mean(mafft$dseq, na.rm = TRUE),
                          mean(prank$dseq, na.rm = TRUE),
                          mean(macse$dseq, na.rm = TRUE),
                          mean(clustal$dseq, na.rm = TRUE)), row.names = c(coati_model, "mafft", "prank", "macse", "clustalo"))
    
    ###########################################################################
    # perfect, best, and imperfect alignments
    source("scripts/number_alignments.R")
    alns = num_alns(results_file)
    
    # fix row and column names and add to stats table
    colnames(alns) = c("Perfect alns", "Best alns", "Imperfect alns")
    alns = alns[c(coati_model, "mafft", "prank", "macse", "clustalo"), ]
    stats_table = cbind(stats_table, alns)
    
    ############################################################################
    # selection (ka ks)
    source("scripts/kaks.R")
    
    aligners = c(coati_model, "mafft", "prank", "macse", "clustalo")
    selection = data.frame("F1.pos" = double(),
                           "F1.neg" = double())
    
    # calculate F1 score for positive and negative selection for each aligner
    for(model in aligners) {
        model_rows = results[which(results$aligner == model), ]
        pos = ps_accuracy(model_rows$ref_omega, model_rows$aln_omega)
        neg = ns_accuracy(model_rows$ref_omega, model_rows$aln_omega)
        
        selection[nrow(selection) + 1, ] = c(pos, neg)
    }
    
    # fix row and column names and add to stats table
    colnames(selection) = c("F1 pos selection", "F1 neg selection")
    rownames(selection) = c("coati", "mafft", "prank", "macse", "clustalo")
    stats_table = cbind(stats_table, selection)
    if(coati_model == "tri-mg") {
        coati_model = "Triplet-MG94"
    } else if(coati_model == "tri-ecm") {
        coati_model = "Triplet-ECM"
    } else if(coati_model == "mar-mg") {
        coati_model = "Marginal-MG94"
    } else if(coati_model == "mar-ecm") {
        coati_model = "Marginal-ECM"
    }
    rownames(stats_table) = c(coati_model, "MAFFT", "PRANK*", "MACSE", "ClustalOmega")
    
    # display stats table
    stats_table
}

wilcoxon_test = function(results_file, coati_model) {
    # read results_summary data
    results = read.csv(results_file)

    # extract dseq values for each aligner
    coati = results$dseq[which(results$aligner == coati_model)]
    clustalomega = results$dseq[which(results$aligner == "clustalo")]
    macse = results$dseq[which(results$aligner == "macse")]
    mafft = results$dseq[which(results$aligner == "mafft")]
    prank = results$dseq[which(results$aligner == "prank")]

    # one-side paired wilcoxon rank test
    wtp = wilcox.test(x = coati, y = prank, paired = TRUE, alternative = "less")
    wtmf = wilcox.test(x = coati, y = mafft, paired = TRUE, alternative = "less")
    wtc = wilcox.test(x = coati, y = clustalomega, paired = TRUE, alternative = "less")
    wtmc = wilcox.test(x = coati, y = macse, paired = TRUE, alternative = "less")
    w = c(wtp$p.value, wtmf$p.value, wtc$p.value, wtmc$p.value)
    w
}
```

# Aligner Commands

We evaluated five different aligners. Below are the commands that we used to run them. We have abbreviated the commands for clarity, stripping out unimportant arguments. Complete workflows can be found in our coati-testing repository on Github.

- COATi: `coati alignpair -m tri-mg ...`
- ClustalÎ© v1.2.4: `clustalo ...`
- PRANK v.150803: `prank -codon ...`
- MACSE v2.06: `java -jar macse.jar -fs_lr 10 -stop_lr 10 -prog alignSequences ...`
- MAFFT v7.505: `mafft --preservecase --globalpair --maxiterate 1000 ...`

COATi can use different alignment models for pairwise alignment. Below are the commands that we used to run different models.

- tri-mg: `coati alignpair -m tri-mg ...`
- tri-ecm: `coati alignpair -m tri-ecm ...`
- mar-mg: `coati alignpair -m mar-mg ...`
- mar-ecm: `coati alignpair -m mar-ecm ...`

# FST Alignment Example

When using the triplet models (tri-mg and tri-ecm), COATi uses the OpenFST library to generate best alignments by composing the input and output sequences with the COATi FST model. While the COATi FST model is too large to display, we can show the result of a composition.

Fig. \@ref(fig:aln-example-a) shows a graph depicting the FST that results from composing the COATi FST with the input sequence "CTC" and the output sequence "CTG". Every path through this FST represents one possible way to align "CTC" and "CTG", and the sum of all weights along a path is the total weight of the respective alignment. Here, the weights of each arc are in negative-log space. Note that this graph has been optimized, and weight has been pushed towards the initial state. The weight of any specific arc may not be directly mapable to a weight described in the model.

Fig. \@ref(fig:aln-example-b) is the best alignment between "CTC" and "CTG", as determined by the shortest path algorithm.  Figs. \@ref(fig:aln-example-a) and \@ref(fig:aln-example-b) were produced by the OpenFST library. A bold circle represents a starting node, and a double circle represents a termination node.

```{r aln-example-a, echo = FALSE, fig.align='center', fig.cap="The FST of all possible alignments between `CTC' and `CTG'."}
knitr::include_graphics("figures/aln-example-graph.pdf")
```

```{r aln-example-b, echo = FALSE, out.width="75%", fig.align='center', fig.cap="The best alignment of `CTC' and `CTG'."}
knitr::include_graphics("figures/aln-example-path.pdf")
```

\newpage

```{r setup-table-results, echo = FALSE}
suppressMessages(library(kableExtra))
suppressMessages(library(knitr))
suppressMessages(library(tidyverse))
```

```{r table-results-1, echo = FALSE, results = 'asis'}
results = "data/tri-mg/results/results_summary.csv"
k = kable(summary_table(results, "tri-mg"), digits = 5, caption = paste("Accuracy of COATi codon-triplet-mg, PRANK, MAFFT, ClustalOmega, and MACSE on 7761 simulated sequence pairs. Perfect alignments have the same score as the true alignment, best alignments have lowest $d_{seq}$, and imperfect alignments have a different score than the true alignment when at least one method found a perfect alignment."), escape = FALSE) %>% kable_styling(latex_options = "HOLD_position")
print(footnote(k, general = "PRANK produced 42 empty alignments, calculations are based on 7719 alignments.", footnote_as_chunk = TRUE, general_title = "*"))
```
```{r table-results-2, echo = FALSE, results = 'asis'}
results = "data/tri-ecm/results/results_summary.csv"
k = kable(summary_table(results, "tri-ecm"), digits = 5, caption = paste("Accuracy of COATi codon-triplet-ecm, PRANK, MAFFT, ClustalOmega, and MACSE on 7761 simulated sequence pairs. Perfect alignments have the same score as the true alignment, best alignments have lowest $d_{seq}$, and imperfect alignments have a different score than the true alignment when at least one method found a perfect alignment."), escape = FALSE) %>% kable_styling(latex_options = "HOLD_position")
print(footnote(k, general = "PRANK produced 69 empty alignments, calculations are based on 7692 alignments.", footnote_as_chunk = TRUE, general_title = "*"))
```
```{r table-results-3, echo = FALSE, results = 'asis'}
results = "data/mar-mg/results/results_summary.csv"
k = kable(summary_table(results, "mar-mg"), digits = 5, caption = paste("Accuracy of COATi codon-marginal-mg, PRANK, MAFFT, ClustalOmega, and MACSE on 7755 simulated sequence pairs. Perfect alignments have the same score as the true alignment, best alignments have lowest $d_{seq}$, and imperfect alignments have a different score than the true alignment when at least one method found a perfect alignment."), escape = FALSE) %>% kable_styling(latex_options = "HOLD_position")
print(footnote(k, general = "PRANK produced 60 empty alignments, calculations are based on 7695 alignments.", footnote_as_chunk = TRUE, general_title = "*"))
```
```{r table-results-4, echo = FALSE, results = 'asis'}
results = "data/mar-ecm/results/results_summary.csv"
k = kable(summary_table(results, "mar-ecm"), digits = 5, caption = paste("Accuracy of COATi codon-marginal-ecm, PRANK, MAFFT, ClustalOmega, and MACSE on 7767 simulated sequence pairs. Perfect alignments have the same score as the true alignment, best alignments have lowest $d_{seq}$, and imperfect alignments have a different score than the true alignment when at least one method found a perfect alignment."), escape = FALSE) %>% kable_styling(latex_options = "HOLD_position")
print(footnote(k, general = "PRANK produced 49 empty alignments, calculations are based on 7718 alignments.", footnote_as_chunk = TRUE, general_title = "*"))
```
```{r table-results-5, echo = FALSE, results = 'asis'}
results = "data/reverse/results/results_summary.csv"
k = kable(summary_table(results, "tri-mg"), digits = 5, caption = paste("Accuracy of COATi codon-triplet-mg, PRANK, MAFFT, ClustalOmega, and MACSE on 7798 simulated sequence pairs with gorilla as the reference. Perfect alignments have the same score as the true alignment, best alignments have lowest $d_{seq}$, and imperfect alignments have a different score than the true alignment when at least one method found a perfect alignment."), escape = FALSE) %>% kable_styling(latex_options = "HOLD_position")
print(footnote(k, general = "PRANK produced 35 empty alignments, calculations are based on 7763 alignments.", footnote_as_chunk = TRUE, general_title = "*"))
```
```{r table-results-6, echo = FALSE, results = 'asis'}
source("scripts/results_gor_ref.R")
k = kable(gor_ref_results(), digits = 5, caption = paste("Accuracy of COATi codon-triplet-mg, PRANK, MAFFT, ClustalOmega, MACSE, and codon-triplet-mg with gorila as the reference on 4003 of the 7761 simulated sequence pairs where the gorilla sequence was simulated without early stop codons, incomplete codons, or ambiguous nucleotides. Perfect alignments have the same score as the true alignment, best alignments have lowest $d_{seq}$, and imperfect alignments have a different score than the true alignment when at least one method found a perfect alignment."), escape = FALSE) %>% kable_styling(latex_options = "HOLD_position")
print(k)
```

\newpage

```{r base-calling-error, echo = FALSE, fig.width = 6, fig.height = 6, fig.cap="\\label{fig:figs} Base calling error FST. Arcs from M to S generate matches; however, here they can introduce single-nucleotide errors, which can generate stop codon artifacts."}
#knitr::include_graphics(path = "figures/fig-base-calling-error.pdf")
```

```{r pvals, echo = FALSE}
results = "data/tri-mg/results/results_summary.csv"
pval_tri_mg = max(wilcoxon_test(results, "tri-mg"))
results = "data/tri-ecm/results/results_summary.csv"
pval_tri_ecm = max(wilcoxon_test(results, "tri-ecm"))
results = "data/mar-mg/results/results_summary.csv"
pval_mar_mg = max(wilcoxon_test(results, "mar-mg"))
results = "data/mar-ecm/results/results_summary.csv"
pval_mar_ecm = max(wilcoxon_test(results, "mar-ecm"))
results = "data/reverse/results/results_summary.csv"
pval_reverse = max(wilcoxon_test(results, "tri-mg"))
```

```{r dseq1, echo = FALSE, fig.width = 6, fig.height = 6, fig.align = 'center', fig.cap = paste0("\\label{fig:dseq-tri-mg} Comparison of log10-transformed $d_{seq}$ data with pseudocounts between COATi codon-triplet-mg and PRANK, MAFFT, ClustalOmega, and MACSE. COATi was significantly more accurate than other aligners; all p-values were $\\leq ", signif(pval_tri_mg, digits = 3), "$.")}
library(knitr)
source("scripts/plot_dseq.R")
suppressWarnings(plot_dseq_main("data/tri-mg/plot_distance.csv", "tri-mg", save = TRUE))
knitr::include_graphics(path = "figures/dseq_plots_tri-mg.pdf")
```

```{r dseq2, echo = FALSE, fig.width = 6, fig.height = 6, fig.align = 'center', fig.cap = paste0("\\label{fig:dseq-tri-ecm} Comparison of log10-transformed $d_{seq}$ data with pseudocounts between COATi codon-triplet-ecm and PRANK, MAFFT, ClustalOmega, and MACSE. COATi was significantly more accurate than other aligners; all p-values were $\\leq ", signif(pval_tri_ecm, digits = 3), "$.")}
library(knitr)
source("scripts/plot_dseq.R")
suppressWarnings(plot_dseq_main("data/tri-ecm/plot_distance.csv", "tri-ecm", save = TRUE))
knitr::include_graphics(path = "figures/dseq_plots_tri-ecm.pdf")
```

```{r dseq3, echo = FALSE, fig.width = 6, fig.height = 6, fig.align = 'center', fig.cap = paste0("\\label{fig:dseq-mar-mg} Comparison of log10-transformed $d_{seq}$ data with pseudocounts between COATi codon-marginal-mg and PRANK, MAFFT, ClustalOmega, and MACSE. COATi was significantly more accurate than other aligners; all p-values were $\\leq ", signif(pval_mar_mg, digits = 3), "$.")}
library(knitr)
source("scripts/plot_dseq.R")
suppressWarnings(plot_dseq_main("data/mar-mg/plot_distance.csv", "mar-mg", save = TRUE))
knitr::include_graphics(path = "figures/dseq_plots_mar-mg.pdf")
```

```{r dseq4, echo = FALSE, fig.width = 6, fig.height = 6, fig.align = 'center', fig.cap = paste0("\\label{fig:dseq-mar-ecm} Comparison of log10-transformed $d_{seq}$ data with pseudocounts between COATi codon-marginal-ecm and PRANK, MAFFT, ClustalOmega, and MACSE. COATi was significantly more accurate than other aligners; all p-values were $\\leq ", signif(pval_mar_ecm, digits = 3), "$.")}
library(knitr)
source("scripts/plot_dseq.R")
suppressWarnings(plot_dseq_main("data/mar-ecm/plot_distance.csv", "mar-ecm", save = TRUE))
knitr::include_graphics(path = "figures/dseq_plots_mar-ecm.pdf")
```

```{r dseq5, echo = FALSE, fig.width = 6, fig.height = 6, fig.align = 'center', fig.cap = paste0("\\label{fig:dseq-reverse} Comparison of log10-transformed $d_{seq}$ data with pseudocounts between COATi codon-triplet-mg and PRANK, MAFFT, ClustalOmega, and MACSE with gorilla as the reference. COATi was significantly more accurate than other aligners; all p-values were $\\leq ", signif(pval_reverse, digits = 3), "$.")}
library(knitr)
source("scripts/plot_dseq.R")
suppressWarnings(plot_dseq_main("data/reverse/plot_distance.csv", "reverse", save = TRUE))
knitr::include_graphics(path = "figures/dseq_plots_reverse.pdf")
```

\newpage

```{r k2p-dist, echo = FALSE, fig.align = 'center', out.width="75%", fig.cap="\\label{fig:k2p} Alignments generated by COATi produce accurate evolutionary distances. Benchmark alignments were realigned by COATi and four other methods as described in the main text. Kimura two-parameter (K2P) distances were estimated from the benchmark alignments and the estimated alignments. Each panel is a scatter plot comparing the benchmark disances (Reference) with distances estimated via one of the aligners. COATi clearly performs better than other tools, which tend to drastically overestimate some distances."}
knitr::include_graphics(path = "figures/k2p_distances.pdf")
```

<!-- \newpage -->

<!-- # Supplementary Methods -->

<!-- Ks and Ka represent the number of substitutions per synonymous and non-synonymous sites. The ratio of nonsynonymous (Ka) to synonymous (Ks) nucleotide substitution rates indicates the selective pressures acting on genes. If the ratio is significantly greater than 1, it suggests positive selective pressure, meaning that nonsynonymous substitutions occur more frequently than synonymous substitutions. A ratio around 1 can indicate either neutral evolution at the protein level or a mixture of positive and negative selective pressures. If the ratio is less than 1, it indicates a pressure to maintain protein sequence, known as purifying selection. -->
<!-- Ks and Ka are calculated using the R package seqinr v.4.2-30 [@seqinr]. -->

<!-- # References -->

<!-- <div id="refs"></div> -->
